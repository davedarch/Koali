<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>drag | koali</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      background-color: #f4f4f4;
      position: relative;
    }

    #instruction {
      font-size: 48px;
      margin-top: 0;
      text-align: center;
      display: flex;
      align-items: center;
      height: 10vh;
      width: 100%;
      background-color: #f4f4f4;
      position: fixed;
      top: 0;
      z-index: 1000;
    }

    #play-icon {
      margin-left: 10px;
      cursor: pointer;
      font-size: 48px;
    }

    .draggable {
      width: 100px;
      height: 100px;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      cursor: grab;
      top: 10vh;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .target {
      width: 120px;
      height: 120px;
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      transition: background-color 0.3s;
      top: 10vh;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .target.active {
      background-color: #2ecc71 !important;
    }

    .circle {
      border-radius: 50%;
    }

    .square {
      border-radius: 8px;
    }

    .triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid;
      background-color: transparent !important;
    }

    .clickable-word {
      margin: 0 5px;
      cursor: pointer;
      transition: color 0.3s, background-color 0.3s;
    }

    .clickable-word:hover {
      color: #3498db;
      background-color: #e0f7fa;
    }

    /* Level indicator styles */
    #level-indicator {
      position: fixed;
      top: 10px;
      right: 20px;
      background-color: #3498db;
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 18px;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    /* Progress bar styles */
    #level-progress-container {
      position: fixed;
      top: 50px;
      right: 20px;
      width: 150px;
      height: 10px;
      background-color: #ecf0f1;
      border-radius: 5px;
      overflow: hidden;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    #level-progress-bar {
      height: 100%;
      width: 0%;
      background-color: #3498db;
      transition: width 0.5s ease-in-out;
    }

    /* Success animation */
    @keyframes success-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .success-animation {
      animation: success-pulse 0.5s ease-in-out;
    }

    /* Level completion animation */
    @keyframes level-complete {
      0% { background-color: #3498db; }
      50% { background-color: #2ecc71; }
      100% { background-color: #3498db; }
    }

    .level-complete-animation {
      animation: level-complete 1s ease-in-out;
    }

    /* Feedback styles */
    #feedback-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #feedback-modal {
      display: none;
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      width: 300px;
      z-index: 1000;
    }

    #feedback-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #feedback-form input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .optional-label {
      color: #666;
      font-size: 12px;
      margin-left: 4px;
    }

    #feedback-form textarea {
      width: 100%;
      height: 100px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }

    #feedback-form button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
    }

    #feedback-form button:hover {
      background-color: #2980b9;
    }

    @keyframes pulse-animation {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    .pulse {
      animation: pulse-animation 2s infinite ease-in-out;
    }
  </style>
</head>
<body>
  <div id="instruction">Drag the blue square onto the red circle</div>
  
  <div id="level-indicator">Level 1</div>
  
  <div id="level-progress-container">
    <div id="level-progress-bar"></div>
  </div>
  
  <div class="draggable" data-color="#3498db"></div>
  <div class="draggable" data-color="#e67e22"></div>
  <div class="draggable" data-color="#9b59b6"></div>
  <div class="draggable" data-color="#f1c40f"></div>
  <div class="draggable" data-color="#c0392b"></div>
  
  <div class="target">Drop here</div>

  <button id="feedback-button">
    <i class="fas fa-comment"></i>
  </button>
  
  <div id="feedback-modal">
    <form id="feedback-form">
      <input type="text" placeholder="Your name">
      <input type="email" placeholder="Your email"><span class="optional-label">(optional)</span>
      <textarea placeholder="Share your feedback or report an issue..."></textarea>
      <button type="submit">Send Feedback</button>
    </form>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/plain-draggable@2.5.15/plain-draggable.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const draggables = document.querySelectorAll('.draggable');
      const target = document.querySelector('.target');
      const instructionElement = document.getElementById('instruction');
      const levelIndicator = document.getElementById('level-indicator');
      const levelProgressBar = document.getElementById('level-progress-bar');
      
      // Level system variables
      let currentLevel = parseInt(localStorage.getItem('dragGameLevel')) || 1;
      const maxLevel = 5; // Maximum level
      let correctDraggable;
      let activeDraggables = [];
      
      // Track progress for current level (0-100)
      let levelProgress = parseInt(localStorage.getItem('dragGameProgress')) || 0;
      let startTime; // To track time for each attempt
      
      // Update level display
      updateLevelDisplay();
      updateProgressBar();

      // Colors for shapes - using the same palette as click-basic.html
      const colors = [
        '#3498db', // blue
        '#e67e22', // orange
        '#9b59b6', // purple
        '#f1c40f', // yellow
        '#c0392b'  // red
      ];

      // Mapping of hex values to color names
      const colorMap = {
        '#3498db': 'blue',
        '#e67e22': 'orange',
        '#9b59b6': 'purple',
        '#f1c40f': 'yellow',
        '#c0392b': 'red'
      };

      // Array of shape classes
      const shapes = ['circle', 'square', 'triangle'];

      // Compute a safe zone that excludes the reserved UI areasâ€”especially the instruction text at the top.
      function getSafeArea() {
        // Get current viewport dimensions
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;

        // Get the bounding rectangle for the instruction element.
        const instructionRect = document.getElementById('instruction').getBoundingClientRect();

        // Use a safety margin to ensure no overlap.
        const safetyMargin = 20;

        // Set safe top to be just below the instruction element.
        const safeTop = instructionRect.bottom + safetyMargin;
        const safeLeft = safetyMargin;
        const safeRight = viewportWidth - safetyMargin;
        const safeBottom = viewportHeight - safetyMargin;

        return { left: safeLeft, top: safeTop, right: safeRight, bottom: safeBottom };
      }

      // Update the randomPosition function to be more robust with zoom levels
      const randomPosition = (element) => {
        // Force layout calculation for accurate measurement
        document.body.offsetHeight;
        
        // Get updated viewport dimensions
        const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
        const viewportHeight = document.documentElement.clientHeight || window.innerHeight;

        // Get element dimensions using getBoundingClientRect for accuracy (handles zoom)
        const elementRect = element.getBoundingClientRect();
        const elementWidth = elementRect.width || element.offsetWidth || 100;
        const elementHeight = elementRect.height || element.offsetHeight || 100;

        // Get the safe area based on reserved UI elements
        const safeArea = getSafeArea();

        // Determine the available space within the safe area
        const availableWidth = safeArea.right - safeArea.left - elementWidth;
        const availableHeight = safeArea.bottom - safeArea.top - elementHeight;

        // Generate a random position within that available area
        let randomX = safeArea.left + Math.floor(Math.random() * (availableWidth > 0 ? availableWidth : 0));
        let randomY = safeArea.top + Math.floor(Math.random() * (availableHeight > 0 ? availableHeight : 0));

        // Clamp the position to ensure the element stays fully within the safe area.
        if (randomX < safeArea.left) randomX = safeArea.left;
        if (randomY < safeArea.top) randomY = safeArea.top;
        if (randomX + elementWidth > safeArea.right) randomX = safeArea.right - elementWidth;
        if (randomY + elementHeight > safeArea.bottom) randomY = safeArea.bottom - elementHeight;

        // Apply the computed position
        element.style.left = `${randomX}px`;
        element.style.top = `${randomY}px`;

        // Log for debugging purposes
        console.log(`Positioned ${element.className} at (${randomX}, ${randomY}), safe area: L${safeArea.left}, T${safeArea.top}, R${safeArea.right}, B${safeArea.bottom}`);
      };

      // Function to check if two elements overlap
      const checkOverlap = (rect1, rect2, margin = 10) => {
        return !(
          rect1.right + margin < rect2.left ||
          rect1.left > rect2.right + margin ||
          rect1.bottom + margin < rect2.top ||
          rect1.top > rect2.bottom + margin
        );
      };

      // Function to position elements without overlap
      const positionWithoutOverlap = (element, activeElements, maxAttempts = 50) => {
        let attempts = 0;
        let overlapping = true;
        
        while (overlapping && attempts < maxAttempts) {
          randomPosition(element);
          overlapping = false;
          
          const elementRect = element.getBoundingClientRect();
          
          for (const otherElement of activeElements) {
            if (element !== otherElement && otherElement.style.opacity !== '0') {
              const otherRect = otherElement.getBoundingClientRect();
              if (checkOverlap(elementRect, otherRect)) {
                overlapping = true;
                break;
              }
            }
          }
          
          attempts++;
        }
        
        return !overlapping;
      };

      // Function to update the level display
      function updateLevelDisplay() {
        levelIndicator.textContent = `Level ${currentLevel}`;
      }

      // Function to update the progress bar
      function updateProgressBar() {
        // Update the progress bar width with animation
        levelProgressBar.style.width = `${levelProgress}%`;
      }

      // Function to setup the game
      function setupGame() {
        // Start timing this attempt
        startTime = Date.now();
        
        // Reset all draggables
        draggables.forEach(draggable => {
          draggable.style.opacity = '0';
          draggable.textContent = '';
          // Remove any existing PlainDraggable instance
          if (draggable._plainDraggable) {
            draggable._plainDraggable.disabled = true;
            draggable._plainDraggable = null;
          }
        });
        
        // Reset target
        target.style.opacity = '0';
        target.textContent = '';
        
        // Determine how many draggables to show based on level
        const draggablesToShow = Math.min(currentLevel + 1, draggables.length);
        
        // Create an array to track used shape/color combinations
        const usedCombinations = [];
        
        // First, set up the target with a random shape and color
        const targetShape = shapes[Math.floor(Math.random() * shapes.length)];
        const targetColor = colors[Math.floor(Math.random() * colors.length)];
        
        // Add target combination to used list
        usedCombinations.push({ shape: targetShape, color: targetColor });
        
        // Set up target
        target.dataset.shape = targetShape;
        target.className = `target ${targetShape}`;
        target.style.backgroundColor = targetColor;
        if (targetShape === 'triangle') {
          target.style.borderBottomColor = targetColor;
        }
        
        // Make the target visible
        target.style.opacity = '1';
        
        // Position the target
        randomPosition(target);
        
        // Randomly select which draggables to show
        activeDraggables = Array.from(draggables)
          .sort(() => 0.5 - Math.random())
          .slice(0, draggablesToShow);
        
        // Set up each draggable with a unique shape/color combination
        activeDraggables.forEach((draggable, index) => {
          let draggableShape, draggableColor;
          let validCombination = false;
          
          // Try to find a unique combination
          while (!validCombination) {
            draggableShape = shapes[Math.floor(Math.random() * shapes.length)];
            draggableColor = colors[Math.floor(Math.random() * colors.length)];
            
            // Check if this combination is already used
            const isDuplicate = usedCombinations.some(combo => 
              combo.shape === draggableShape && combo.color === draggableColor
            );
            
            if (!isDuplicate) {
              validCombination = true;
              usedCombinations.push({ shape: draggableShape, color: draggableColor });
            }
          }
          
          // Set the draggable's shape and color
          draggable.dataset.shape = draggableShape;
          draggable.className = `draggable ${draggableShape}`;
          draggable.style.backgroundColor = draggableColor;
          if (draggableShape === 'triangle') {
            draggable.style.borderBottomColor = draggableColor;
          }
          
          // Make the draggable visible
          draggable.style.opacity = '1';
        });
        
        // Now choose one draggable to be the correct one
        const correctIndex = Math.floor(Math.random() * activeDraggables.length);
        correctDraggable = activeDraggables[correctIndex];
        
        // Helper function to get the color name from an element
        function getColorName(element) {
          // Try to get the color from backgroundColor style
          let color = element.style.backgroundColor;
          
          // If it's a hex color (from our colors array)
          if (element.style.backgroundColor.startsWith('#')) {
            return colorMap[element.style.backgroundColor] || 'unknown';
          }
          
          // If it's an RGB color (browser might convert hex to rgb)
          if (element.style.backgroundColor.startsWith('rgb')) {
            // Convert RGB to hex
            const rgb = element.style.backgroundColor.match(/\d+/g);
            if (rgb && rgb.length === 3) {
              const hex = '#' + 
                ('0' + parseInt(rgb[0], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2);
              
              // Try to find the color in our map
              return colorMap[hex] || 'unknown';
            }
          }
          
          // If all else fails, try to use the data-color attribute
          return colorMap[element.dataset.color] || 'unknown';
        }
        
        // Get the correct draggable's color and shape
        const correctColor = getColorName(correctDraggable);
        const correctShape = correctDraggable.dataset.shape;
        
        // Get the target's color and shape
        const targetColorName = getColorName(target);
        const targetShapeName = target.dataset.shape;
        
        // Position all elements without overlap
        // First position the target
        const allElements = [target];
        
        // Then position each draggable one by one, avoiding overlap with previously positioned elements
        for (const draggable of activeDraggables) {
          let positioned = false;
          let attempts = 0;
          const maxAttempts = 50;
          
          while (!positioned && attempts < maxAttempts) {
            randomPosition(draggable);
            positioned = true;
            
            // Check for overlap with any previously positioned element
            for (const element of allElements) {
              const rect1 = draggable.getBoundingClientRect();
              const rect2 = element.getBoundingClientRect();
              
              // Check if they overlap (with a margin)
              const margin = 20;
              if (!(
                rect1.right + margin < rect2.left ||
                rect1.left > rect2.right + margin ||
                rect1.bottom + margin < rect2.top ||
                rect1.top > rect2.bottom + margin
              )) {
                positioned = false;
                randomPosition(draggable);
                
                // Update PlainDraggable position if applicable
                if (element._plainDraggable) {
                  element._plainDraggable.position();
                }
                
                break;
              }
            }
            
            attempts++;
          }
          
          // Add this draggable to the positioned elements list
          allElements.push(draggable);
        }
        
        // Update instruction text with clickable words
        const instructionText = `Drag the ${correctColor} ${correctShape} onto the ${targetColorName} ${targetShapeName}`;
        const words = instructionText.split(' ');
        instructionElement.innerHTML = words.map(word => `<span class="clickable-word">${word}</span>`).join(' ') + ' <i id="play-icon" class="fas fa-play-circle"></i>';
        
        // Add pulsing animation to target in level 1
        if (currentLevel === 1) {
          target.classList.add('pulse');
          
          // Remove any existing target label
          const targetLabel = document.getElementById('target-label');
          if (targetLabel) {
            targetLabel.style.display = 'none';
          }
        } else {
          target.classList.remove('pulse');
        }
        
        // Clear any text inside the target
        target.textContent = '';
        
        // Initialize draggables with PlainDraggable
        activeDraggables.forEach(draggable => {
          // Create a new PlainDraggable instance for each active draggable
          const draggableInstance = new PlainDraggable(draggable);

          // Store the instance on the element for later reference
          draggable._plainDraggable = draggableInstance;
          
          // Set up drag start event
          draggableInstance.onDragStart = () => {
            isDragging = true;
            startTime = Date.now(); // Start timing when drag begins
          };
          
          // Set up drag end event
          draggableInstance.onDragEnd = () => {
            isDragging = false;
            
            // Check if the draggable is now off-screen and reposition if needed
            const draggableRect = draggable.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (draggableRect.right > viewportWidth || draggableRect.bottom > viewportHeight || 
                draggableRect.left < 0 || draggableRect.top < 0) {
              // Reposition this element
              randomPosition(draggable);
              draggableInstance.position();
            }
            
            // Check for drop on target
            const targetRect = target.getBoundingClientRect();
            
            // Check if this draggable overlaps with the target
            const isOverlapping = !(
              draggableRect.right < targetRect.left ||
              draggableRect.left > targetRect.right ||
              draggableRect.bottom < targetRect.top ||
              draggableRect.top > targetRect.bottom
            );
            
            // Check if this is the correct draggable
            const isCorrectDrop = draggable === correctDraggable && isOverlapping;
            
            // Handle the drop result
            handleDrop(draggable, isCorrectDrop);
          };
        });

        // Adjust target size based on level (gets closer to draggable size as level increases)
        const draggableSize = 100; // Base draggable size
        const initialTargetSize = 140; // Start with a more noticeable size difference
        const finalTargetSize = 100; // By level 5, same size as draggables

        // Calculate target size based on current level
        const targetSizeDifference = initialTargetSize - finalTargetSize;
        const levelRatio = (maxLevel - currentLevel) / (maxLevel - 1); // From 1.0 at level 1 to 0.0 at max level
        const currentTargetSize = finalTargetSize + (targetSizeDifference * levelRatio);
        
        if (targetShape === 'triangle') {
          // Clear any previous non-triangle styles and set width/height to 0
          target.style.width = '0';
          target.style.height = '0';
          target.style.backgroundColor = 'transparent';
          // For triangle targets, use borders for drawing the shape
          const borderSize = currentTargetSize / 2;
          target.style.borderLeft = `${borderSize}px solid transparent`;
          target.style.borderRight = `${borderSize}px solid transparent`;
          target.style.borderBottom = `${currentTargetSize}px solid ${targetColor}`;
        } else {
          // For non-triangle targets, clear any triangle border styles and apply dimensions normally
          target.style.borderLeft = '';
          target.style.borderRight = '';
          target.style.borderBottom = '';
          target.style.width = `${currentTargetSize}px`;
          target.style.height = `${currentTargetSize}px`;
          target.style.backgroundColor = targetColor;
        }
      }

      // Function to check if drag was successful
      function checkDragSuccess(draggable) {
        const draggableRect = draggable.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        const endTime = Date.now();
        const timeTaken = (endTime - startTime) / 1000; // Convert to seconds

        if (
          draggable === correctDraggable && // Check if the correct shape is dragged
            draggableRect.left < targetRect.right &&
            draggableRect.right > targetRect.left &&
            draggableRect.top < targetRect.bottom &&
            draggableRect.bottom > targetRect.top
          ) {
          // Success! Add success animation
          target.classList.add('success-animation');
          
          // Calculate progress increase based on time taken
          // Faster drags = more progress
          let progressIncrease = 20; // Base progress
          
          // Adjust based on time (faster = more progress, up to +10%)
          if (timeTaken < 1) {
            progressIncrease += 10;
          } else if (timeTaken < 2) {
            progressIncrease += 5;
          }
          
          // Increase level progress
          levelProgress += progressIncrease;
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Check if level is complete
          if (levelProgress >= 100) {
            // Level complete animation
            levelProgressBar.classList.add('level-complete-animation');
            
            // Reset progress for next level
            levelProgress = 0;
            localStorage.setItem('dragGameProgress', levelProgress);
            
            // Increase level
            currentLevel++;
            
            // Check if we've completed all levels
            if (currentLevel <= maxLevel) {
              // Save level state
              localStorage.setItem('dragGameLevel', currentLevel);
              
              // Update level display
              updateLevelDisplay();
              
              // Remove level completion animation after a delay
              setTimeout(() => {
                levelProgressBar.classList.remove('level-complete-animation');
              }, 1000);
            } else {
              // If we've completed the final level, show a completion message and redirect to home
              showCompletionMessage();
              return; // Exit the function early to prevent setting up a new game
            }
          }
          
          // Disable all draggables to prevent further interaction
          activeDraggables.forEach(draggable => {
            if (draggable._plainDraggable) {
              draggable._plainDraggable.disabled = true;
            }
          });
          
          // Set up next round after a short delay
            setTimeout(() => {
            // Don't change target color here - it will be set in the next setupGame call
            setupGame();
          }, 1000);
        } else {
          // Incorrect drag - small penalty to progress (5%)
          levelProgress = Math.max(0, levelProgress - 5);
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Return the draggable to its original position
          if (draggable._plainDraggable) {
            draggable._plainDraggable.position();
          }
        }
      }

      // Reset button (for testing) - double click on level indicator
      levelIndicator.addEventListener('dblclick', () => {
        localStorage.setItem('dragGameLevel', 1);
        localStorage.setItem('dragGameProgress', 0);
        currentLevel = 1;
        levelProgress = 0;
        updateLevelDisplay();
        updateProgressBar();
        setupGame();
      });

      // Initialize the game
      setupGame();

      // Feedback functionality
      const feedbackButton = document.getElementById('feedback-button');
      const feedbackModal = document.getElementById('feedback-modal');
      const feedbackForm = document.getElementById('feedback-form');

      feedbackButton.addEventListener('click', () => {
        feedbackModal.style.display = feedbackModal.style.display === 'none' ? 'block' : 'none';
      });

      feedbackForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const feedback = feedbackForm.querySelector('textarea').value;
        const name = feedbackForm.querySelector('input[type="text"]').value;
        const email = feedbackForm.querySelector('input[type="email"]').value;
        
        try {
          if (!feedback.trim()) {
            throw new Error('Please enter some feedback before submitting');
          }

          // First save to local server
          const response = await fetch('/submit-feedback', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              feedback,
              name,
              email
            })
          });

          const data = await response.json();
          
          if (response.ok) {
            alert('Thank you for your feedback!');
            feedbackForm.querySelector('textarea').value = '';
            feedbackForm.querySelector('input[type="text"]').value = '';
            feedbackForm.querySelector('input[type="email"]').value = '';
            feedbackModal.style.display = 'none';
          } else {
            throw new Error(data.error || 'Failed to submit feedback');
          }
        } catch (error) {
          console.error('Detailed error:', error);
          
          // Create a more user-friendly error message
          let userMessage = 'Sorry, there was an error submitting your feedback: ';
          
          if (error.message.includes('Failed to fetch')) {
            userMessage += 'Network error - please check your internet connection.';
          } else if (error.message.includes('API Error')) {
            userMessage += error.message;
          } else {
            userMessage += error.message;
          }
          
          alert(userMessage);
        }
      });

      // Close modal when clicking outside
      document.addEventListener('click', (e) => {
        if (!feedbackModal.contains(e.target) && e.target !== feedbackButton) {
          feedbackModal.style.display = 'none';
        }
      });

      // Function to show completion message and redirect to home
      function showCompletionMessage() {
        // Create a completion overlay
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '2000';
        
        // Create congratulations message
        const message = document.createElement('h1');
        message.textContent = 'Congratulations!';
        message.style.color = 'white';
        message.style.fontSize = '3rem';
        message.style.marginBottom = '20px';
        message.style.textAlign = 'center';
        
        // Create sub-message
        const subMessage = document.createElement('p');
        subMessage.textContent = 'You have completed all levels of the Drag skill!';
        subMessage.style.color = 'white';
        subMessage.style.fontSize = '1.5rem';
        subMessage.style.marginBottom = '30px';
        subMessage.style.textAlign = 'center';
        
        // Create home button
        const homeButton = document.createElement('button');
        homeButton.textContent = 'Return to Home';
        homeButton.style.padding = '15px 30px';
        homeButton.style.fontSize = '1.2rem';
        homeButton.style.backgroundColor = '#3498db';
        homeButton.style.color = 'white';
        homeButton.style.border = 'none';
        homeButton.style.borderRadius = '30px';
        homeButton.style.cursor = 'pointer';
        homeButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        
        // Add hover effect
        homeButton.onmouseover = () => {
          homeButton.style.backgroundColor = '#2980b9';
        };
        homeButton.onmouseout = () => {
          homeButton.style.backgroundColor = '#3498db';
        };
        
        // Add click event to redirect to home
        homeButton.onclick = () => {
          // Reset game state before redirecting
          localStorage.setItem('dragGameLevel', 1);
          localStorage.setItem('dragGameProgress', 0);
          
          // Redirect to home page
          window.location.href = '/';
        };
        
        // Add elements to overlay
        overlay.appendChild(message);
        overlay.appendChild(subMessage);
        overlay.appendChild(homeButton);
        
        // Add overlay to body
        document.body.appendChild(overlay);
        
        // Add confetti effect
        createConfetti();
      }
      
      // Function to create confetti effect
      function createConfetti() {
        const confettiCount = 200;
        const colors = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6'];
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.style.position = 'fixed';
          confetti.style.width = `${Math.random() * 10 + 5}px`;
          confetti.style.height = `${Math.random() * 5 + 5}px`;
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.top = '-10px';
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.opacity = Math.random();
          confetti.style.zIndex = '1999';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          
          document.body.appendChild(confetti);
          
          // Animate confetti
          const duration = Math.random() * 3 + 2;
          const delay = Math.random() * 2;
          
          confetti.animate([
            { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
            { transform: `translate(${Math.random() * 100 - 50}px, ${window.innerHeight}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
          ], {
            duration: duration * 1000,
            delay: delay * 1000,
            easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
            fill: 'forwards'
          });
          
          // Remove confetti after animation
          setTimeout(() => {
            document.body.removeChild(confetti);
          }, (duration + delay) * 1000);
        }
      }

      // Also update the window resize handler to be more aggressive about keeping elements on screen
      window.addEventListener('resize', () => {
        // Only reposition if we're not in the middle of a drag operation
        if (!isDragging) {
          console.log("Window resized, repositioning elements");
          
          // Get all visible elements
          const visibleElements = [...document.querySelectorAll('.draggable, .target')]
            .filter(el => el.style.opacity !== '0');
          
          // Force layout calculation
          document.body.offsetHeight;
          
          // Get current viewport dimensions
          const viewportWidth = document.documentElement.clientWidth || window.innerWidth;
          const viewportHeight = document.documentElement.clientHeight || window.innerHeight;
          
          console.log(`Current viewport: ${viewportWidth}x${viewportHeight}`);
          
          // First, just reposition all elements to ensure they're on screen
          visibleElements.forEach(element => {
            randomPosition(element);
            
            // If this is a draggable with PlainDraggable instance, update it
            if (element._plainDraggable) {
              element._plainDraggable.position();
            }
          });
          
          // Then check for overlaps and fix them
          for (let i = 0; i < visibleElements.length; i++) {
            const element = visibleElements[i];
            let positioned = false;
            let attempts = 0;
            const maxAttempts = 50;
            
            while (!positioned && attempts < maxAttempts) {
              positioned = true;
              
              // Check for overlap with any other visible element
              for (let j = 0; j < visibleElements.length; j++) {
                if (i !== j) {
                  const otherElement = visibleElements[j];
                  const rect1 = element.getBoundingClientRect();
                  const rect2 = otherElement.getBoundingClientRect();
                  
                  // Check if they overlap (with a margin)
                  const margin = 20;
                  if (!(
                    rect1.right + margin < rect2.left ||
                    rect1.left > rect2.right + margin ||
                    rect1.bottom + margin < rect2.top ||
                    rect1.top > rect2.bottom + margin
                  )) {
                    positioned = false;
                    randomPosition(element);
                    
                    // Update PlainDraggable position if applicable
                    if (element._plainDraggable) {
                      element._plainDraggable.position();
                    }
                    
                    break;
                  }
                }
              }
              
              // Also check if element is now off-screen
              const rect = element.getBoundingClientRect();
              if (
                rect.right > viewportWidth || 
                rect.bottom > viewportHeight || 
                rect.left < 0 || 
                rect.top < 0
              ) {
                positioned = false;
                randomPosition(element);
                
                // Update PlainDraggable position if applicable
                if (element._plainDraggable) {
                  element._plainDraggable.position();
                }
              }
              
              attempts++;
            }
          }
        }
      });

      // Add a flag to track if we're currently dragging
      let isDragging = false;

      // Add this function to handle the drop result
      function handleDrop(draggable, isCorrectDrop) {
        const endTime = Date.now();
        const timeTaken = (endTime - startTime) / 1000; // Convert to seconds
        
        if (isCorrectDrop) {
          // Remove the pulse animation
          target.classList.remove('pulse');
          
          // Success! Add success animation
          target.classList.add('success-animation');
          
          // Calculate progress increase based on time taken
          // Faster drops = more progress
          let progressIncrease = 20; // Base progress
          
          // Adjust based on time (faster = more progress, up to +10%)
          if (timeTaken < 1) {
            progressIncrease += 10;
          } else if (timeTaken < 2) {
            progressIncrease += 5;
          }
          
          // Increase level progress
          levelProgress += progressIncrease;
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Check if level is complete
          if (levelProgress >= 100) {
            // Level complete animation
            levelProgressBar.classList.add('level-complete-animation');
            
            // Reset progress for next level
            levelProgress = 0;
            localStorage.setItem('dragGameProgress', levelProgress);
            
            // Increase level
            currentLevel++;
            
            // Check if we've completed all levels
            if (currentLevel <= maxLevel) {
              // Save level state
              localStorage.setItem('dragGameLevel', currentLevel);
              
              // Update level display
              updateLevelDisplay();
              
              // Remove level completion animation after a delay
              setTimeout(() => {
                levelProgressBar.classList.remove('level-complete-animation');
              }, 1000);
            } else {
              // If we've completed the final level, show a completion message and redirect to home
              showCompletionMessage();
              return; // Exit the function early to prevent setting up a new game
            }
          }
          
          // Disable all draggables to prevent further interaction
          activeDraggables.forEach(draggable => {
            if (draggable._plainDraggable) {
              draggable._plainDraggable.disabled = true;
            }
          });
          
          // Set up next round after a short delay
          setTimeout(() => {
            target.classList.remove('success-animation');
            setupGame();
          }, 1000);
        } else {
          // Incorrect drag - small penalty to progress (5%)
          levelProgress = Math.max(0, levelProgress - 5);
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Return the draggable to its original position
          if (draggable._plainDraggable) {
            draggable._plainDraggable.position();
          }
        }
      }
    });
  </script>
</body>
</html>