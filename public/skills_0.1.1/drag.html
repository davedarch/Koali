<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>drag | koali</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      background-color: #f4f4f4;
      position: relative;
    }

    #instruction {
      font-size: 48px;
      margin-top: 0;
      text-align: center;
      display: flex;
      align-items: center;
      height: 10vh;
      width: 100%;
      background-color: #f4f4f4;
      position: fixed;
      top: 0;
      z-index: 1000;
    }

    #play-icon {
      margin-left: 10px;
      cursor: pointer;
      font-size: 48px;
    }

    .draggable {
      width: 100px;
      height: 100px;
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      position: absolute;
      cursor: grab;
      top: 10vh;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .target {
      width: 120px;
      height: 120px;
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      transition: background-color 0.3s;
      top: 10vh;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
    }

    .target.active {
      background-color: #2ecc71 !important;
    }

    .circle {
      border-radius: 50%;
    }

    .square {
      border-radius: 8px;
    }

    .triangle {
      width: 0;
      height: 0;
      border-left: 50px solid transparent;
      border-right: 50px solid transparent;
      border-bottom: 100px solid;
      background-color: transparent !important;
    }

    .clickable-word {
      margin: 0 5px;
      cursor: pointer;
      transition: color 0.3s, background-color 0.3s;
    }

    .clickable-word:hover {
      color: #3498db;
      background-color: #e0f7fa;
    }

    /* Level indicator styles */
    #level-indicator {
      position: fixed;
      top: 10px;
      right: 20px;
      background-color: #3498db;
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 18px;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    /* Progress bar styles */
    #level-progress-container {
      position: fixed;
      top: 50px;
      right: 20px;
      width: 150px;
      height: 10px;
      background-color: #ecf0f1;
      border-radius: 5px;
      overflow: hidden;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    #level-progress-bar {
      height: 100%;
      width: 0%;
      background-color: #3498db;
      transition: width 0.5s ease-in-out;
    }

    /* Success animation */
    @keyframes success-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .success-animation {
      animation: success-pulse 0.5s ease-in-out;
    }

    /* Level completion animation */
    @keyframes level-complete {
      0% { background-color: #3498db; }
      50% { background-color: #2ecc71; }
      100% { background-color: #3498db; }
    }

    .level-complete-animation {
      animation: level-complete 1s ease-in-out;
    }

    /* Feedback styles */
    #feedback-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #feedback-modal {
      display: none;
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      width: 300px;
      z-index: 1000;
    }

    #feedback-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #feedback-form input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .optional-label {
      color: #666;
      font-size: 12px;
      margin-left: 4px;
    }

    #feedback-form textarea {
      width: 100%;
      height: 100px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }

    #feedback-form button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
    }

    #feedback-form button:hover {
      background-color: #2980b9;
    }
  </style>
</head>
<body>
  <div id="instruction">Drag the blue square onto the red circle</div>
  
  <div id="level-indicator">Level 1</div>
  
  <div id="level-progress-container">
    <div id="level-progress-bar"></div>
  </div>
  
  <div class="draggable" data-color="#3498db"></div>
  <div class="draggable" data-color="#e67e22"></div>
  <div class="draggable" data-color="#9b59b6"></div>
  <div class="draggable" data-color="#f1c40f"></div>
  <div class="draggable" data-color="#c0392b"></div>
  
  <div class="target">Drop here</div>

  <button id="feedback-button">
    <i class="fas fa-comment"></i>
  </button>
  
  <div id="feedback-modal">
    <form id="feedback-form">
      <input type="text" placeholder="Your name">
      <input type="email" placeholder="Your email"><span class="optional-label">(optional)</span>
      <textarea placeholder="Share your feedback or report an issue..."></textarea>
      <button type="submit">Send Feedback</button>
    </form>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/plain-draggable@2.5.15/plain-draggable.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const draggables = document.querySelectorAll('.draggable');
      const target = document.querySelector('.target');
      const instructionElement = document.getElementById('instruction');
      const levelIndicator = document.getElementById('level-indicator');
      const levelProgressBar = document.getElementById('level-progress-bar');
      
      // Level system variables
      let currentLevel = parseInt(localStorage.getItem('dragGameLevel')) || 1;
      const maxLevel = 5; // Maximum level
      let correctDraggable;
      let activeDraggables = [];
      
      // Track progress for current level (0-100)
      let levelProgress = parseInt(localStorage.getItem('dragGameProgress')) || 0;
      let startTime; // To track time for each attempt
      
      // Update level display
      updateLevelDisplay();
      updateProgressBar();

      // Colors for shapes - using the same palette as click-basic.html
      const colors = [
        '#3498db', // blue
        '#e67e22', // orange
        '#9b59b6', // purple
        '#f1c40f', // yellow
        '#c0392b'  // red
      ];

      // Mapping of hex values to color names
      const colorMap = {
        '#3498db': 'blue',
        '#e67e22': 'orange',
        '#9b59b6': 'purple',
        '#f1c40f': 'yellow',
        '#c0392b': 'red'
      };

      // Array of shape classes
      const shapes = ['circle', 'square', 'triangle'];

      // Function to generate random positions, avoiding the top 10% of the screen and ensuring elements stay on screen
      const randomPosition = (element) => {
        // Get the visible viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Get element dimensions
        const elementWidth = element.offsetWidth || 100; // Default to 100 if not yet rendered
        const elementHeight = element.offsetHeight || 100;
        
        // Calculate maximum positions to keep element fully on screen
        // Add a 20px margin to ensure elements aren't right at the edge
        const maxX = Math.max(0, viewportWidth - elementWidth - 20);
        const maxY = Math.max(0, viewportHeight - elementHeight - 20);
        
        // Ensure top 10% of screen is avoided
        const minY = viewportHeight * 0.1;
        
        // Generate random positions within safe bounds
        const randomX = Math.min(Math.max(20, Math.floor(Math.random() * maxX)), maxX);
        const randomY = Math.min(Math.max(minY, Math.floor(Math.random() * maxY)), maxY);
        
        // Apply positions
        element.style.left = `${randomX}px`;
        element.style.top = `${randomY}px`;
      };

      // Function to check if two elements overlap
      const checkOverlap = (rect1, rect2, margin = 10) => {
        return !(
          rect1.right + margin < rect2.left ||
          rect1.left > rect2.right + margin ||
          rect1.bottom + margin < rect2.top ||
          rect1.top > rect2.bottom + margin
        );
      };

      // Function to position elements without overlap
      const positionWithoutOverlap = (element, activeElements, maxAttempts = 50) => {
        let attempts = 0;
        let overlapping = true;
        
        while (overlapping && attempts < maxAttempts) {
          randomPosition(element);
          overlapping = false;
          
          const elementRect = element.getBoundingClientRect();
          
          for (const otherElement of activeElements) {
            if (element !== otherElement && otherElement.style.opacity !== '0') {
              const otherRect = otherElement.getBoundingClientRect();
              if (checkOverlap(elementRect, otherRect)) {
                overlapping = true;
                break;
              }
            }
          }
          
          attempts++;
        }
        
        return !overlapping;
      };

      // Function to update the level display
      function updateLevelDisplay() {
        levelIndicator.textContent = `Level ${currentLevel}`;
      }

      // Function to update the progress bar
      function updateProgressBar() {
        // Update the progress bar width with animation
        levelProgressBar.style.width = `${levelProgress}%`;
      }

      // Function to set up the game based on current level
      function setupGame() {
        // Start timing this attempt
        startTime = Date.now();
        
        // Reset all draggables and target
        draggables.forEach(draggable => {
          draggable.style.opacity = '0';
          draggable.classList.remove('circle', 'square', 'triangle');
          draggable.style.borderBottomColor = '';
          draggable.style.backgroundColor = draggable.dataset.color;
          
          // Remove any existing draggable instances
          if (draggable._plainDraggable) {
            draggable._plainDraggable.disabled = true;
          }
        });
        
        target.style.opacity = '0';
        target.classList.remove('circle', 'square', 'triangle');
        target.style.borderBottomColor = '';
        
        // Determine how many draggables to show based on level
        const draggablesToShow = Math.min(currentLevel, draggables.length);
        
        // Randomly select which draggables to show
        activeDraggables = Array.from(draggables)
          .sort(() => 0.5 - Math.random())
          .slice(0, draggablesToShow);
        
        // First, set up the target with a random shape and color
        const targetShape = shapes[Math.floor(Math.random() * shapes.length)];
        const targetColor = colors[Math.floor(Math.random() * colors.length)];
        target.dataset.shape = targetShape;
        target.className = `target ${targetShape}`;
        target.style.backgroundColor = targetColor;
        target.style.borderBottomColor = targetColor; // For triangles
        
        // Make the target visible
        target.style.opacity = '1';
        
        // Position the target first
        randomPosition(target);
        
        // Now set up the draggables, ensuring none match the target's shape and color
        activeDraggables.forEach((draggable, index) => {
          // Choose a random shape and color that doesn't match the target
          let draggableShape, draggableColor;
          
          do {
            draggableShape = shapes[Math.floor(Math.random() * shapes.length)];
            draggableColor = colors[Math.floor(Math.random() * colors.length)];
          } while (
            // Don't allow the same shape AND color as the target
            (draggableShape === targetShape && draggableColor === targetColor) ||
            // Don't allow duplicates among draggables
            activeDraggables.some((d, i) => 
              i < index && // Only check draggables we've already set up
              d.dataset.shape === draggableShape && 
              d.style.backgroundColor === draggableColor
            )
          );
          
          // Set the draggable's shape and color
          draggable.dataset.shape = draggableShape;
          draggable.className = `draggable ${draggableShape}`;
          draggable.style.backgroundColor = draggableColor;
          draggable.style.borderBottomColor = draggableColor; // For triangles
          
          // Make the draggable visible
          draggable.style.opacity = '1';
        });
        
        // Now choose one draggable to be the correct one
        const correctIndex = Math.floor(Math.random() * activeDraggables.length);
        correctDraggable = activeDraggables[correctIndex];
        
        // Helper function to get the color name from an element
        function getColorName(element) {
          // Try to get the color from backgroundColor style
          let color = element.style.backgroundColor;
          
          // If it's a hex color (from our colors array)
          if (element.style.backgroundColor.startsWith('#')) {
            return colorMap[element.style.backgroundColor] || 'unknown';
          }
          
          // If it's an RGB color (browser might convert hex to rgb)
          if (element.style.backgroundColor.startsWith('rgb')) {
            // Convert RGB to hex
            const rgb = element.style.backgroundColor.match(/\d+/g);
            if (rgb && rgb.length === 3) {
              const hex = '#' + 
                ('0' + parseInt(rgb[0], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2);
              
              // Try to find the color in our map
              return colorMap[hex] || 'unknown';
            }
          }
          
          // If all else fails, try to use the data-color attribute
          return colorMap[element.dataset.color] || 'unknown';
        }

        // Get the correct draggable's color and shape
        const correctColor = getColorName(correctDraggable);
        const correctShape = correctDraggable.dataset.shape;

        // Get the target's color and shape
        const targetColorName = getColorName(target);
        const targetShapeName = target.dataset.shape;
        
        // Position all draggables without overlap
        const allElements = [target, ...activeDraggables];
        for (let i = 1; i < allElements.length; i++) {
          positionWithoutOverlap(allElements[i], allElements.slice(0, i));
        }

        // Update instruction text with clickable words
        const instructionText = `Drag the ${correctColor} ${correctShape} onto the ${targetColorName} ${targetShapeName}`;
        const words = instructionText.split(' ');
        instructionElement.innerHTML = words.map(word => `<span class="clickable-word">${word}</span>`).join(' ') + ' <i id="play-icon" class="fas fa-play-circle"></i>';

        // Only show "Drop here" text in level 1, and position it below the target
        if (currentLevel === 1) {
          // Create or get the target label
          let targetLabel = document.getElementById('target-label');
          if (!targetLabel) {
            targetLabel = document.createElement('div');
            targetLabel.id = 'target-label';
            targetLabel.style.position = 'absolute';
            targetLabel.style.color = 'black';
            targetLabel.style.fontWeight = 'bold';
            targetLabel.style.textAlign = 'center';
            targetLabel.style.width = '120px';
            document.body.appendChild(targetLabel);
          }
          
          targetLabel.textContent = 'Drop here';
          targetLabel.style.display = 'block';
          
          // Position the label below the target
          const targetRect = target.getBoundingClientRect();
          targetLabel.style.left = `${targetRect.left}px`;
          targetLabel.style.top = `${targetRect.bottom + 10}px`; // 10px below the target
          
          // Clear any text inside the target itself
          target.textContent = '';
        } else {
          // Hide the label in higher levels
          const targetLabel = document.getElementById('target-label');
          if (targetLabel) {
            targetLabel.style.display = 'none';
          }
          target.textContent = '';
        }

        // Add event listeners to each word
        document.querySelectorAll('.clickable-word').forEach(span => {
          span.addEventListener('click', () => {
            const utterance = new SpeechSynthesisUtterance(span.textContent);
            utterance.rate = 0.75; // Set a slightly slower rate if needed
            window.speechSynthesis.speak(utterance);
          });
        });

        // Update the click handler for the play icon
        document.getElementById('play-icon').addEventListener('click', () => {
          let delay = 0;

          words.forEach((word, index) => {
            setTimeout(() => {
              const utterance = new SpeechSynthesisUtterance(word);
              utterance.rate = 0.75; // Set a slightly slower rate if needed
              window.speechSynthesis.speak(utterance);
            }, delay);

            // Increase delay for the next word
            delay += 500; // 500ms pause between words
          });
        });

        // Initialize draggables with PlainDraggable
        activeDraggables.forEach(draggable => {
          // Create a new PlainDraggable instance for each active draggable
          const draggableInstance = new PlainDraggable(draggable);
          
          // Store the instance on the element for later reference
          draggable._plainDraggable = draggableInstance;
          
          // Set up drag start event
          draggableInstance.onDragStart = () => {
            isDragging = true;
            startTime = Date.now(); // Start timing when drag begins
          };
          
          // Set up drag end event
          draggableInstance.onDragEnd = () => {
            isDragging = false;
            
            // Check if the draggable is now off-screen and reposition if needed
            const draggableRect = draggable.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            if (draggableRect.right > viewportWidth || draggableRect.bottom > viewportHeight || 
                draggableRect.left < 0 || draggableRect.top < 0) {
              // Reposition this element
              randomPosition(draggable);
              draggableInstance.position();
            }
            
            // Check for drop on target
            const targetRect = target.getBoundingClientRect();
            
            // Check if this draggable overlaps with the target
            const isOverlapping = !(
              draggableRect.right < targetRect.left ||
              draggableRect.left > targetRect.right ||
              draggableRect.bottom < targetRect.top ||
              draggableRect.top > targetRect.bottom
            );
            
            // Check if this is the correct draggable
            const isCorrectDrop = draggable === correctDraggable && isOverlapping;
            
            // Handle the drop result
            handleDrop(draggable, isCorrectDrop);
          };
        });
      }

      // Function to check if drag was successful
      function checkDragSuccess(draggable) {
        const draggableRect = draggable.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();
        const endTime = Date.now();
        const timeTaken = (endTime - startTime) / 1000; // Convert to seconds

        if (
          draggable === correctDraggable && // Check if the correct shape is dragged
          draggableRect.left < targetRect.right &&
          draggableRect.right > targetRect.left &&
          draggableRect.top < targetRect.bottom &&
          draggableRect.bottom > targetRect.top
        ) {
          // Success! Add success animation
          target.classList.add('success-animation');
          
          // Calculate progress increase based on time taken
          // Faster drags = more progress
          let progressIncrease = 20; // Base progress
          
          // Adjust based on time (faster = more progress, up to +10%)
          if (timeTaken < 1) {
            progressIncrease += 10;
          } else if (timeTaken < 2) {
            progressIncrease += 5;
          }
          
          // Increase level progress
          levelProgress += progressIncrease;
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Check if level is complete
          if (levelProgress >= 100) {
            // Level complete animation
            levelProgressBar.classList.add('level-complete-animation');
            
            // Reset progress for next level
            levelProgress = 0;
            localStorage.setItem('dragGameProgress', levelProgress);
            
            // Increase level
            currentLevel++;
            
            // Check if we've completed all levels
            if (currentLevel <= maxLevel) {
              // Save level state
              localStorage.setItem('dragGameLevel', currentLevel);
              
              // Update level display
              updateLevelDisplay();
              
              // Remove level completion animation after a delay
              setTimeout(() => {
                levelProgressBar.classList.remove('level-complete-animation');
              }, 1000);
            } else {
              // If we've completed the final level, show a completion message and redirect to home
              showCompletionMessage();
              return; // Exit the function early to prevent setting up a new game
            }
          }
          
          // Disable all draggables to prevent further interaction
          activeDraggables.forEach(draggable => {
            if (draggable._plainDraggable) {
              draggable._plainDraggable.disabled = true;
            }
          });
          
          // Set up next round after a short delay
          setTimeout(() => {
            // Don't change target color here - it will be set in the next setupGame call
            setupGame();
          }, 1000);
        } else {
          // Incorrect drag - small penalty to progress (5%)
          levelProgress = Math.max(0, levelProgress - 5);
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Return the draggable to its original position
          if (draggable._plainDraggable) {
            draggable._plainDraggable.position();
          }
        }
      }

      // Reset button (for testing) - double click on level indicator
      levelIndicator.addEventListener('dblclick', () => {
        localStorage.setItem('dragGameLevel', 1);
        localStorage.setItem('dragGameProgress', 0);
        currentLevel = 1;
        levelProgress = 0;
        updateLevelDisplay();
        updateProgressBar();
        setupGame();
      });

      // Initialize the game
      setupGame();

      // Feedback functionality
      const feedbackButton = document.getElementById('feedback-button');
      const feedbackModal = document.getElementById('feedback-modal');
      const feedbackForm = document.getElementById('feedback-form');

      feedbackButton.addEventListener('click', () => {
        feedbackModal.style.display = feedbackModal.style.display === 'none' ? 'block' : 'none';
      });

      feedbackForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const feedback = feedbackForm.querySelector('textarea').value;
        const name = feedbackForm.querySelector('input[type="text"]').value;
        const email = feedbackForm.querySelector('input[type="email"]').value;
        
        try {
          if (!feedback.trim()) {
            throw new Error('Please enter some feedback before submitting');
          }

          // First save to local server
          const response = await fetch('/submit-feedback', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              feedback,
              name,
              email
            })
          });

          const data = await response.json();
          
          if (response.ok) {
            alert('Thank you for your feedback!');
            feedbackForm.querySelector('textarea').value = '';
            feedbackForm.querySelector('input[type="text"]').value = '';
            feedbackForm.querySelector('input[type="email"]').value = '';
            feedbackModal.style.display = 'none';
          } else {
            throw new Error(data.error || 'Failed to submit feedback');
          }
        } catch (error) {
          console.error('Detailed error:', error);
          
          // Create a more user-friendly error message
          let userMessage = 'Sorry, there was an error submitting your feedback: ';
          
          if (error.message.includes('Failed to fetch')) {
            userMessage += 'Network error - please check your internet connection.';
          } else if (error.message.includes('API Error')) {
            userMessage += error.message;
          } else {
            userMessage += error.message;
          }
          
          alert(userMessage);
        }
      });

      // Close modal when clicking outside
      document.addEventListener('click', (e) => {
        if (!feedbackModal.contains(e.target) && e.target !== feedbackButton) {
          feedbackModal.style.display = 'none';
        }
      });

      // Function to show completion message and redirect to home
      function showCompletionMessage() {
        // Create a completion overlay
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '2000';
        
        // Create congratulations message
        const message = document.createElement('h1');
        message.textContent = 'Congratulations!';
        message.style.color = 'white';
        message.style.fontSize = '3rem';
        message.style.marginBottom = '20px';
        message.style.textAlign = 'center';
        
        // Create sub-message
        const subMessage = document.createElement('p');
        subMessage.textContent = 'You have completed all levels of the Drag skill!';
        subMessage.style.color = 'white';
        subMessage.style.fontSize = '1.5rem';
        subMessage.style.marginBottom = '30px';
        subMessage.style.textAlign = 'center';
        
        // Create home button
        const homeButton = document.createElement('button');
        homeButton.textContent = 'Return to Home';
        homeButton.style.padding = '15px 30px';
        homeButton.style.fontSize = '1.2rem';
        homeButton.style.backgroundColor = '#3498db';
        homeButton.style.color = 'white';
        homeButton.style.border = 'none';
        homeButton.style.borderRadius = '30px';
        homeButton.style.cursor = 'pointer';
        homeButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        
        // Add hover effect
        homeButton.onmouseover = () => {
          homeButton.style.backgroundColor = '#2980b9';
        };
        homeButton.onmouseout = () => {
          homeButton.style.backgroundColor = '#3498db';
        };
        
        // Add click event to redirect to home
        homeButton.onclick = () => {
          // Reset game state before redirecting
          localStorage.setItem('dragGameLevel', 1);
          localStorage.setItem('dragGameProgress', 0);
          
          // Redirect to home page
          window.location.href = '/';
        };
        
        // Add elements to overlay
        overlay.appendChild(message);
        overlay.appendChild(subMessage);
        overlay.appendChild(homeButton);
        
        // Add overlay to body
        document.body.appendChild(overlay);
        
        // Add confetti effect
        createConfetti();
      }
      
      // Function to create confetti effect
      function createConfetti() {
        const confettiCount = 200;
        const colors = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6'];
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.style.position = 'fixed';
          confetti.style.width = `${Math.random() * 10 + 5}px`;
          confetti.style.height = `${Math.random() * 5 + 5}px`;
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.top = '-10px';
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.opacity = Math.random();
          confetti.style.zIndex = '1999';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          
          document.body.appendChild(confetti);
          
          // Animate confetti
          const duration = Math.random() * 3 + 2;
          const delay = Math.random() * 2;
          
          confetti.animate([
            { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
            { transform: `translate(${Math.random() * 100 - 50}px, ${window.innerHeight}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
          ], {
            duration: duration * 1000,
            delay: delay * 1000,
            easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
            fill: 'forwards'
          });
          
          // Remove confetti after animation
          setTimeout(() => {
            document.body.removeChild(confetti);
          }, (duration + delay) * 1000);
        }
      }

      // Add a window resize handler to reposition elements if they go off-screen
      window.addEventListener('resize', () => {
        // Only reposition if we're not in the middle of a drag operation
        if (!isDragging) {
          // Get all visible elements
          const visibleElements = [...document.querySelectorAll('.draggable, .target')]
            .filter(el => el.style.opacity !== '0');
          
          // Reposition any elements that are off-screen
          visibleElements.forEach(element => {
            const rect = element.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Check if element is partially off-screen
            if (rect.right > viewportWidth || rect.bottom > viewportHeight || 
                rect.left < 0 || rect.top < 0) {
              // Reposition this element
              randomPosition(element);
              
              // If this is a draggable with PlainDraggable instance, update it
              if (element._plainDraggable) {
                element._plainDraggable.position();
              }
            }
          });
          
          // After repositioning, check for overlaps and fix them
          for (let i = 0; i < visibleElements.length; i++) {
            positionWithoutOverlap(visibleElements[i], visibleElements);
            
            // Update PlainDraggable position if applicable
            if (visibleElements[i]._plainDraggable) {
              visibleElements[i]._plainDraggable.position();
            }
          }
        }
      });

      // Add a flag to track if we're currently dragging
      let isDragging = false;

      // Add this function to handle the drop result
      function handleDrop(draggable, isCorrectDrop) {
        const endTime = Date.now();
        const timeTaken = (endTime - startTime) / 1000; // Convert to seconds
        
        if (isCorrectDrop) {
          // Success! Add success animation
          target.classList.add('success-animation');
          
          // Calculate progress increase based on time taken
          // Faster drops = more progress
          let progressIncrease = 20; // Base progress
          
          // Adjust based on time (faster = more progress, up to +10%)
          if (timeTaken < 1) {
            progressIncrease += 10;
          } else if (timeTaken < 2) {
            progressIncrease += 5;
          }
          
          // Increase level progress
          levelProgress += progressIncrease;
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Check if level is complete
          if (levelProgress >= 100) {
            // Level complete animation
            levelProgressBar.classList.add('level-complete-animation');
            
            // Reset progress for next level
            levelProgress = 0;
            localStorage.setItem('dragGameProgress', levelProgress);
            
            // Increase level
            currentLevel++;
            
            // Check if we've completed all levels
            if (currentLevel <= maxLevel) {
              // Save level state
              localStorage.setItem('dragGameLevel', currentLevel);
              
              // Update level display
              updateLevelDisplay();
              
              // Remove level completion animation after a delay
              setTimeout(() => {
                levelProgressBar.classList.remove('level-complete-animation');
              }, 1000);
            } else {
              // If we've completed the final level, show a completion message and redirect to home
              showCompletionMessage();
              return; // Exit the function early to prevent setting up a new game
            }
          }
          
          // Disable all draggables to prevent further interaction
          activeDraggables.forEach(draggable => {
            if (draggable._plainDraggable) {
              draggable._plainDraggable.disabled = true;
            }
          });
          
          // Set up next round after a short delay
          setTimeout(() => {
            target.classList.remove('success-animation');
            setupGame();
          }, 1000);
        } else {
          // Incorrect drag - small penalty to progress (5%)
          levelProgress = Math.max(0, levelProgress - 5);
          localStorage.setItem('dragGameProgress', levelProgress);
          
          // Update progress bar
          updateProgressBar();
          
          // Return the draggable to its original position
          if (draggable._plainDraggable) {
            draggable._plainDraggable.position();
          }
        }
      }
    });
  </script>
</body>
</html>