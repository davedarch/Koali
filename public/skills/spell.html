<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>spell | koali</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <style>
    :root {
      --square-size: 180px;
      --font-size: 72px;
      --word-font-size: 108px;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #d3d3f3;
      user-select: none;
      max-width: 1400px;
      margin: 0 auto;
    }

    #word-container {
      font-size: var(--word-font-size);
      margin: 40px 0;
      text-align: center;
      display: flex;
      align-items: center;
    }

    #draggables-container, #sequence-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 40px 0;
      width: 95vw;
      max-width: 1400px;
    }

    .draggable, .sequence-slot {
      width: var(--square-size);
      height: var(--square-size);
      color: black;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 10px;
      flex-shrink: 0;
      cursor: grab;
      border: 6px solid #3498db;
      border-radius: 24px;
      background-color: white;
      font-size: var(--font-size);
      font-weight: bold;
    }

    .draggable.dragging {
      opacity: 0.5;
    }

    .sequence-slot.over {
      background-color: #e0f7fa;
      border-color: #1abc9c;
    }

    #feedback {
      font-size: 60px;
      margin-top: 60px;
      height: 72px;
    }

    #play-icon {
      cursor: pointer;
      font-size: 108px;
      margin-left: 30px;
    }

    /* Challenge mode icon style - smaller and all black */
    .challenge-icon {
      font-size: 48px !important;
      color: black !important;
      margin-left: 10px;
    }

    .clickable-word {
      margin: 0 15px;
      cursor: pointer;
      transition: color 0.3s, background-color 0.3s;
    }

    .clickable-word:hover {
      color: #3498db;
      background-color: #e0f7fa;
    }
    
    /* Level system styles */
    #level-indicator {
      position: fixed;
      top: 10px;
      right: 20px;
      background-color: #3498db;
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 18px;
      z-index: 1001;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }

    #level-progress-container {
      position: fixed;
      top: 50px;
      right: 20px;
      width: 150px;
      height: 10px;
      background-color: #e0e0e0;
      border-radius: 5px;
      overflow: hidden;
      z-index: 1001;
    }

    #level-progress-bar {
      height: 100%;
      background-color: #2ecc71;
      width: 0%;
      transition: width 0.3s ease-in-out;
    }
    
    /* Success animation */
    @keyframes success-pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .success-animation {
      animation: success-pulse 0.5s ease-in-out;
    }
    
    /* Level completion animation */
    @keyframes level-complete {
      0% { background-color: #2ecc71; }
      50% { background-color: #f1c40f; }
      100% { background-color: #2ecc71; }
    }
    
    .level-complete-animation {
      animation: level-complete 1s ease-in-out;
    }
    
    /* Feedback styles */
    #feedback-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #feedback-modal {
      display: none;
      position: fixed;
      bottom: 80px;
      right: 20px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      width: 300px;
      z-index: 1000;
    }

    #feedback-form {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #feedback-form input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    .optional-label {
      color: #666;
      font-size: 12px;
      margin-left: 4px;
    }

    #feedback-form textarea {
      width: 100%;
      height: 100px;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
    }

    #feedback-form button {
      background-color: #3498db;
      color: white;
      border: none;
      padding: 8px;
      border-radius: 4px;
      cursor: pointer;
    }

    #feedback-form button:hover {
      background-color: #2980b9;
    }

    @keyframes float-fade {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-50px); opacity: 0; }
    }

    .float-fade-animation {
      animation: float-fade 1.2s ease-out forwards;
    }

    @keyframes float-fade-up {
      0% { transform: translateY(0); opacity: 1; }
      100% { transform: translateY(-80px); opacity: 0; }
    }

    .float-fade-letters {
      animation: float-fade-up 0.8s ease-out forwards;
    }

    /* Add these styles in */
    .key-hint {
      position: absolute;
      top: -20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
      padding: 2px 5px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 1000;
    }

    /* Add these styles in the existing <style> section */
    .draggable {
      position: relative;
      transition: transform 0.2s;
    }

    .draggable:hover {
      transform: scale(1.05);
    }

    /* Add keyboard hint styling */
    .key-hint {
      position: absolute;
      bottom: 5px;
      right: 5px;
      font-size: 0.4em;
      opacity: 0.6;
    }

    /* Add a subtle highlight effect when pressing keys */
    .draggable.keyboard-highlight {
      animation: highlight 0.3s ease-out;
    }

    @keyframes highlight {
      0% { background-color: #e0f7fa; }
      100% { background-color: white; }
    }
  </style>
</head>
<body>
  <div id="word-container">
    <span id="current-word" class="clickable-word">Loading...</span>
    <i id="play-icon" class="fas fa-play-circle"></i>
  </div>
  
  <div id="draggables-container">
    <!-- Draggable letters will be dynamically added here -->
  </div>
  
  <div id="sequence-container">
    <!-- Sequence slots will be dynamically added here -->
  </div>
  
  <div id="feedback"></div>
  
  <!-- Level indicator and progress bar -->
  <div id="level-indicator">Level 1</div>
  <div id="level-progress-container">
    <div id="level-progress-bar"></div>
  </div>
  
  <!-- Feedback button and modal -->
  <button id="feedback-button">
    <i class="fas fa-comment"></i>
  </button>
  
  <div id="feedback-modal">
    <form id="feedback-form">
      <input type="text" placeholder="Your name">
      <input type="email" placeholder="Your email"><span class="optional-label">(optional)</span>
      <textarea placeholder="Share your feedback or report an issue..."></textarea>
      <button type="submit">Send Feedback</button>
    </form>
  </div>

  <script>
    console.log('Script starting...');

    const DEBUG = true; // Set to true when testing

    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM loaded');
      const wordContainer = document.getElementById('word-container');
      const currentWordElement = document.getElementById('current-word');
      const draggablesContainer = document.getElementById('draggables-container');
      const sequenceContainer = document.getElementById('sequence-container');
      const feedback = document.getElementById('feedback');
      const playIcon = document.getElementById('play-icon');
      const levelIndicator = document.getElementById('level-indicator');
      const levelProgressBar = document.getElementById('level-progress-bar');
      const feedbackButton = document.getElementById('feedback-button');
      const feedbackModal = document.getElementById('feedback-modal');
      const feedbackForm = document.getElementById('feedback-form');

      let currentWord = '';
      let draggedElement = null;
      let startTime; // To track time for each attempt
      
      // Level system variables
      let currentPhase = parseInt(localStorage.getItem('spellGamePhase')) || 1;
      let currentFileIndex = parseInt(localStorage.getItem('spellGameFileIndex')) || 0;
      const maxPhase = 8; // Currently only using Phase 1 files
      let gameProgress = parseInt(localStorage.getItem('spellGameProgress')) || 0;
      let challengeMode = false; // Track if we're in the audio-only challenge mode
      
      // Word lists organized by phase and files
      const phaseFiles = {
        1: [
          'phonics/Phase1.1_BasicCVCWords.txt',
          'phonics/Phase1.2_BlendingPractice.txt',
          'phonics/Phase1.3_EarlyDigraphWords.txt',
          'phonics/Phase1.4_ShortVowelFamilies.txt',
          'phonics/Phase1.5_TrickyWords.txt'
        ],
        2: [
          'phonics/Phase2.1_ConsonantBlends.txt',
          'phonics/Phase2.2_DigraphExpansion.txt',
          'phonics/Phase2.3_EarlyVowelTeams.txt',
          'phonics/Phase2.4_SplitDigraphs.txt',
          'phonics/Phase2.5_TrickyWords.txt'
        ],
        3: [
          'phonics/Phase3.1_AlternativeGraphemes.txt',
          'phonics/Phase3.2_ConsonantClusters.txt',
          'phonics/Phase3.3_RControlledVowels.txt',
          'phonics/Phase3.4_SoftCG.txt',
          'phonics/Phase3.5_TrickyWords.txt'
        ],
        4: [
          'phonics/Phase4.1_ComplexAlternativeGraphemes.txt',
          'phonics/Phase4.2_Homophones.txt',
          'phonics/Phase4.3_LongerConsonantClusters.txt',
          'phonics/Phase4.4_SilentLetters.txt',
          'phonics/Phase4.5_TrickyWords.txt'
        ],
        5: [
          'phonics/Phase5.1_AdvancedAlternativeSpellings.txt',
          'phonics/Phase5.2_ComplexVowelSounds.txt',
          'phonics/Phase5.3_LatinGreekRoots.txt',
          'phonics/Phase5.4_SuffixesPrefixes.txt',
          'phonics/Phase5.5_TrickyWords.txt'
        ],
        // Add advanced skills section
        6: [
          'phonics-advanced-skills/Module1.1_AdvancedSpellingPatterns.txt',
          'phonics-advanced-skills/Module1.2_WordRoots.txt',
          'phonics-advanced-skills/Module1.3_MultisyllabicWords.txt',
          'phonics-advanced-skills/Module1.4_AdvancedAffixes.txt',
          'phonics-advanced-skills/Module1.5_EtymologyPatterns.txt'
        ],
        7: [
          'phonics-advanced-skills/Module2.1_AcademicWords.txt',
          'phonics-advanced-skills/Module2.2_ContentAreaVocabulary.txt',
          'phonics-advanced-skills/Module2.3_SpecializedTerminology.txt',
          'phonics-advanced-skills/Module2.4_TechnicalWords.txt',
          'phonics-advanced-skills/Module2.5_ProfessionalVocabulary.txt'
        ],
        8: [
          'phonics-advanced-skills/Module3.1_FigurativeLanguage.txt',
          'phonics-advanced-skills/Module3.2_IdiomsAndPhrases.txt',
          'phonics-advanced-skills/Module3.3_ContextualMeanings.txt',
          'phonics-advanced-skills/Module3.4_WordRelationships.txt',
          'phonics-advanced-skills/Module3.5_AdvancedWordOrigins.txt'
        ]
      };
      
      // Get current file path
      function getCurrentFilePath() {
        return phaseFiles[currentPhase][currentFileIndex];
      }
      
      // Get current file name (for display)
      function getCurrentFileName() {
        const path = getCurrentFilePath();
        // Extract the file name without extension and remove Phase prefix
        const fileName = path.split('/').pop().replace('.txt', '').replace(/^Phase\d+_/, '');
        // Convert camelCase to spaces (e.g., ShortVowelFamilies -> Short Vowel Families)
        return fileName.replace(/([A-Z])/g, ' $1').trim();
      }
      
      // Current words for the current file
      let currentFileWords = [];

      // Initialize variables for tracking word count
      let currentWordIndex = 1;
      let totalWordsInFile = 0;
      
      // Update phase display
      function updatePhaseDisplay() {
        const fileName = getCurrentFileName();
        const totalWords = totalWordsInFile || 0;
        
        levelIndicator.textContent = `Phase ${currentPhase}: ${fileName} (${currentWordIndex}/${totalWords})${challengeMode ? ' - Challenge' : ''}`;
      }

      // Update the progress bar
      function updateProgressBar() {
        levelProgressBar.style.width = `${gameProgress}%`;
      }

      // Load words from the current text file
      const loadWords = async () => {
        console.log('About to load words');
        try {
          const filePath = getCurrentFilePath();
          console.log(`Attempting to load words from: ${filePath}`);
          
          const response = await fetch(filePath);
          if (!response.ok) {
            console.error(`Failed to load words: ${response.status} ${response.statusText}`);
            throw new Error(`Failed to load words: ${response.status}`);
          }
          
          const text = await response.text();
          console.log(`Successfully loaded words from ${filePath}:`, text);
          
          const words = text.split('\n')
            .map(word => word.trim())
            .filter(word => word.length > 0);
            
          console.log(`Processed ${words.length} words from file`);
          console.log('Words loaded successfully');
          return words;
        } catch (error) {
          console.error('Detailed error loading words:', error);
          // Fallback to basic words if file loading fails
          alert(`Failed to load words. Using fallback words instead. Error: ${error.message}`);
          return ['cat', 'dog', 'run', 'jump', 'play', 'big', 'red', 'sun', 'hat', 'map'];
        }
      };

      // Shuffle array in-place
      const shuffleArray = (array) => {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      };

      // Create draggable letter
      const createDraggable = (letter, index) => {
        const draggable = document.createElement('div');
        draggable.classList.add('draggable');
        draggable.setAttribute('draggable', 'true');
        draggable.textContent = letter;

        // Event listeners for drag and drop
        draggable.addEventListener('dragstart', (e) => {
          draggedElement = draggable;
          e.dataTransfer.setData('text/plain', index);
          setTimeout(() => {
            draggable.classList.add('dragging');
          }, 0);
        });

        draggable.addEventListener('dragend', () => {
          draggedElement = null;
          draggable.classList.remove('dragging');
        });

        // Add click event to play letter sound
        draggable.addEventListener('click', () => {
          const utterance = new SpeechSynthesisUtterance(letter);
          window.speechSynthesis.speak(utterance);
        });

        // Add visual feedback for keyboard input
        const highlightDraggable = () => {
          draggable.classList.add('keyboard-highlight');
          setTimeout(() => {
            draggable.classList.remove('keyboard-highlight');
          }, 300);
        };

        // Store the letter for keyboard matching
        draggable.setAttribute('data-letter', letter.toLowerCase());

        draggablesContainer.appendChild(draggable);
      };

      // Create sequence slots
      const createSequenceSlots = (word) => {
        sequenceContainer.innerHTML = ''; // Clear previous slots
        for (let i = 0; i < word.length; i++) {
          const slot = document.createElement('div');
          slot.classList.add('sequence-slot');
          slot.setAttribute('data-slot', i);

          // Event listeners for drop targets
          slot.addEventListener('dragover', (e) => {
            e.preventDefault();
            slot.classList.add('over');
          });

          slot.addEventListener('dragleave', () => {
            slot.classList.remove('over');
          });

          slot.addEventListener('drop', (e) => {
            e.preventDefault();
            slot.classList.remove('over');
            if (draggedElement) {
              // If slot already has a child, return it to draggables
              if (slot.firstChild) {
                draggablesContainer.appendChild(slot.firstChild);
              }
              slot.appendChild(draggedElement);

              // Check if the word is spelled correctly after each drop
              checkWord();
            }
          });

          sequenceContainer.appendChild(slot);
        }
      };

      // Initialize the game
      const initGame = async () => {
        console.log('About to initialize game');
        try {
          console.log("Initializing game...");
          
          // If we haven't already loaded words (from startGame), then load them
          if (!currentFileWords || currentFileWords.length === 0) {
            console.log("No words loaded in initGame, loading from file...");
            currentFileWords = await loadWords();
            if (currentFileWords.length === 0) {
              throw new Error("No words were loaded from the file");
            }
            shuffleArray(currentFileWords);
            console.log(`Loaded and shuffled ${currentFileWords.length} words`);
          }
          
          if (currentFileWords.length === 0) {
            currentWordElement.textContent = 'No words available.';
            console.error("No words available after loading attempt");
            return;
          }

          // Start timing this attempt
          startTime = Date.now();

          // FIX: Always get a new word if currentWord is empty, regardless of challenge mode
          if (!challengeMode || !currentWord) {
            currentWord = currentFileWords.shift();
            console.log(`Selected new word: ${currentWord}`);
            
            // Update the word count based on words consumed
            currentWordIndex = totalWordsInFile - currentFileWords.length;
            
            if (currentFileWords.length === 0) {
              // All words have been used—reload and reshuffle
              console.log("Used all words, reloading file...");
              currentFileWords = await loadWords();
              shuffleArray(currentFileWords);
              console.log(`Reloaded ${currentFileWords.length} words`);
            }
          } else {
            console.log(`Using same word in challenge mode: ${currentWord}`);
          }
          
          // Update the display with current word count
          updatePhaseDisplay();
          
          // In challenge mode, hide the word and play the audio
          if (challengeMode) {
            currentWordElement.textContent = ""; // Remove the "Listen" text
            // Center the icon by adjusting margin
            playIcon.style.margin = "0 auto";
            // Play the word audio automatically
            setTimeout(() => {
              const utterance = new SpeechSynthesisUtterance(currentWord);
              utterance.rate = 0.75;
              window.speechSynthesis.speak(utterance);
            }, 500);
          } else {
            currentWordElement.textContent = currentWord;
            // Reset margin to original
            playIcon.style.margin = "";
          }

          // Calculate dynamic sizes based on word length
          const updateSquareSizes = () => {
            // Use the container width instead of window width
            const containerWidth = Math.min(window.innerWidth * 0.95, 1400); // 95% of window width, max 1400px
            const wordLength = currentWord.length;
            const totalMargins = (wordLength - 1) * 20; // 10px margin on each side
            const totalBorders = wordLength * 12; // 6px border on each side
            
            // Calculate size accounting for margins and borders, with 15% increase
            const squareSize = Math.min(
              ((containerWidth - totalMargins - totalBorders) / wordLength) * 1.15,
              207 // Maximum size cap (180 * 1.15)
            );
            
            // Ensure minimum size of 46px (40 * 1.15)
            const finalSize = Math.max(squareSize, 46);
            
            // Update CSS variables with proportional font sizes
            document.documentElement.style.setProperty('--square-size', `${finalSize}px`);
            document.documentElement.style.setProperty('--font-size', `${Math.max(finalSize * 0.45, 23)}px`);
            document.documentElement.style.setProperty('--word-font-size', `${Math.max(finalSize * 0.6, 35)}px`);
          };

          // Call initially and add resize listener
          updateSquareSizes();
          window.addEventListener('resize', updateSquareSizes);

          // FIX: Add safety check before creating jumbled letters
          if (!currentWord || currentWord.length === 0) {
            console.error("Cannot initialize game with empty word");
            currentWord = "error"; // Fallback to prevent crashes
            currentWordElement.textContent = "Error loading word";
            return;
          }

          // Create jumbled letters
          const letters = currentWord.split('');
          shuffleArray(letters);

          // FIX: Add safety counter to prevent infinite loop
          let shuffleAttempts = 0;
          const MAX_SHUFFLE_ATTEMPTS = 10;
          while (letters.join('') === currentWord && shuffleAttempts < MAX_SHUFFLE_ATTEMPTS) {
            shuffleArray(letters);
            shuffleAttempts++;
          }

          // Clear previous content
          draggablesContainer.innerHTML = '';
          feedback.textContent = '';

          // Create draggables and slots
          letters.forEach((letter, index) => createDraggable(letter, index));
          createSequenceSlots(currentWord);
          updateDraggableStyles();
        } catch (error) {
          console.error("Error initializing game:", error);
          currentWordElement.textContent = `Error loading game: ${error.message}`;
        }
        console.log('Game initialized successfully');
      };

      // Updated checkWord function that hides target boxes and animates letter clones
      const checkWord = () => {
        const slots = sequenceContainer.querySelectorAll('.sequence-slot');
        let spelledWord = '';
        let allSlotsFilled = true;
        
        slots.forEach(slot => {
          if (slot.firstChild) {
            spelledWord += slot.firstChild.textContent;
          } else {
            allSlotsFilled = false;
          }
        });

        // Only check if every slot is filled
        if (!allSlotsFilled) return;

        if (spelledWord === currentWord) {
          // Success! Create clones that animate from their actual (lower on screen) positions.
          const clones = [];
          slots.forEach((slot, index) => {
            if (slot.firstChild) {
              const letter = slot.firstChild;
              // Get the letter's current on-screen coordinates,
              // taking into account scroll offset so it's relative to the document.
              const rect = letter.getBoundingClientRect();
              const clone = letter.cloneNode(true);
              clone.style.position = 'absolute';
              clone.style.left = (rect.left + window.scrollX) + 'px';
              clone.style.top = (rect.top + window.scrollY) + 'px';
              clone.style.margin = 0;
              clone.style.zIndex = 2100; // ensures it sits on top of everything
              clone.style.pointerEvents = 'none';
              // Set the transform origin so the animation starts from the letter's own position.
              clone.style.transformOrigin = 'top left';
              // Delay each clone's animation for a sequential effect.
              clone.style.animationDelay = (index * 100) + 'ms';
              clone.classList.add('float-fade-letters');
              document.body.appendChild(clone);
              clones.push(clone);
            }
          });
          
          // Hide the target boxes so only the clones (animated letters) remain visible.
          sequenceContainer.style.visibility = 'hidden';

          // Calculate and update progress.
          const progressPerWord = 100 / totalWordsInFile;
          const progressIncrement = progressPerWord / 2; // Half for normal, half for challenge
          gameProgress += progressIncrement;
          localStorage.setItem('spellGameProgress', gameProgress);
          updateProgressBar();

          // Check if it's time to load a new file/phase.
          if (gameProgress >= 100) {
            levelProgressBar.classList.add('level-complete-animation');
            gameProgress = 0;
            localStorage.setItem('spellGameProgress', gameProgress);
            const currentPhaseFiles = phaseFiles[currentPhase];
            if (currentFileIndex < currentPhaseFiles.length - 1) {
              currentFileIndex++;
              localStorage.setItem('spellGamePhase', currentPhase);
              localStorage.setItem('spellGameFileIndex', currentFileIndex);
              loadNewFile();
            } else if (currentPhase < maxPhase) {
              currentPhase++;
              currentFileIndex = 0;
              localStorage.setItem('spellGamePhase', currentPhase);
              localStorage.setItem('spellGameFileIndex', currentFileIndex);
              loadNewFile();
            } else if (currentFileIndex >= currentPhaseFiles.length - 1 && currentPhase >= maxPhase) {
              showCompletionMessage();
              return; // Exit early to prevent a new round
            }
            setTimeout(() => {
              levelProgressBar.classList.remove('level-complete-animation');
            }, 1000);
          } else {
            // If not advancing, toggle challenge mode.
            if (!challengeMode) {
              challengeMode = true;
              localStorage.setItem('spellGameChallengeMode', challengeMode);
              updatePhaseDisplay();
            } else {
              challengeMode = false;
              localStorage.setItem('spellGameChallengeMode', challengeMode);
              updatePhaseDisplay();
            }
          }
          
          // After the animation finishes, cleanup and start the next round.
          setTimeout(() => {
            clones.forEach(clone => clone.remove());
            sequenceContainer.style.visibility = 'visible';
            initGame();
          }, 1500);
        }
      };
      
      // When loading a new file, reset the progress
      async function loadNewFile() {
        // Reset progress for the new file
        gameProgress = 0;
        localStorage.setItem('spellGameProgress', gameProgress);
        updateProgressBar();
        
        // Load words for the new file
        const allWords = await loadWords();
        currentFileWords = allWords;
        totalWordsInFile = allWords.length;
        console.log(`Total words in new file: ${totalWordsInFile}`);
        
        // Reset challenge mode
        challengeMode = false;
        localStorage.setItem('spellGameChallengeMode', challengeMode);
        
        // Update display
        updatePhaseDisplay();
      }
      
      // Function to show completion message
      function showCompletionMessage() {
        // Create a completion overlay
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        overlay.style.display = 'flex';
        overlay.style.flexDirection = 'column';
        overlay.style.justifyContent = 'center';
        overlay.style.alignItems = 'center';
        overlay.style.zIndex = '2000';
        
        // Create congratulations message
        const message = document.createElement('h1');
        message.textContent = 'Congratulations!';
        message.style.color = 'white';
        message.style.fontSize = '3rem';
        message.style.marginBottom = '20px';
        message.style.textAlign = 'center';
        
        // Create sub-message
        const subMessage = document.createElement('p');
        subMessage.textContent = 'You have completed all levels of the Spell skill!';
        subMessage.style.color = 'white';
        subMessage.style.fontSize = '1.5rem';
        subMessage.style.marginBottom = '30px';
        subMessage.style.textAlign = 'center';
        
        // Create home button
        const homeButton = document.createElement('button');
        homeButton.textContent = 'Return to Home';
        homeButton.style.padding = '15px 30px';
        homeButton.style.fontSize = '1.2rem';
        homeButton.style.backgroundColor = '#3498db';
        homeButton.style.color = 'white';
        homeButton.style.border = 'none';
        homeButton.style.borderRadius = '30px';
        homeButton.style.cursor = 'pointer';
        homeButton.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
        
        // Add hover effect
        homeButton.onmouseover = () => {
          homeButton.style.backgroundColor = '#2980b9';
        };
        homeButton.onmouseout = () => {
          homeButton.style.backgroundColor = '#3498db';
        };
        
        // Add click event to redirect to home
        homeButton.onclick = () => {
          // Reset game state before redirecting
          localStorage.setItem('spellGamePhase', 1);
          localStorage.setItem('spellGameFileIndex', 0);
          localStorage.setItem('spellGameProgress', 0);
          localStorage.setItem('spellGameChallengeMode', false);
          
          // Redirect to home page
          window.location.href = '/';
        };
        
        // Add elements to overlay
        overlay.appendChild(message);
        overlay.appendChild(subMessage);
        overlay.appendChild(homeButton);
        
        // Add overlay to body
        document.body.appendChild(overlay);
        
        // Add confetti effect
        createConfetti();
      }
      
      // Function to create confetti effect
      function createConfetti() {
        const confettiCount = 200;
        const colors = ['#f1c40f', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6'];
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.style.position = 'fixed';
          confetti.style.width = `${Math.random() * 10 + 5}px`;
          confetti.style.height = `${Math.random() * 5 + 5}px`;
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.top = '-10px';
          confetti.style.left = `${Math.random() * 100}vw`;
          confetti.style.opacity = Math.random();
          confetti.style.zIndex = '1999';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          
          document.body.appendChild(confetti);
          
          // Animate confetti
          const duration = Math.random() * 3 + 2;
          const delay = Math.random() * 2;
          
          confetti.animate([
            { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
            { transform: `translate(${Math.random() * 100 - 50}px, ${window.innerHeight}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
          ], {
            duration: duration * 1000,
            delay: delay * 1000,
            easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
            fill: 'forwards'
          });
          
          // Remove confetti after animation
          setTimeout(() => {
            document.body.removeChild(confetti);
          }, (duration + delay) * 1000);
        }
      }

      // Play the entire word
      playIcon.addEventListener('click', () => {
        const utterance = new SpeechSynthesisUtterance(currentWord);
        utterance.rate = 0.75; // Slightly slower rate for clarity
        window.speechSynthesis.speak(utterance);
      });

      // Reset button (for testing) - double click on level indicator
      levelIndicator.addEventListener('dblclick', () => {
        localStorage.setItem('spellGamePhase', 1);
        localStorage.setItem('spellGameFileIndex', 0);
        localStorage.setItem('spellGameProgress', 0);
        localStorage.setItem('spellGameChallengeMode', false);
        currentPhase = 1;
        currentFileIndex = 0;
        gameProgress = 0;
        challengeMode = false;
        currentFileWords = []; // Force reload of words
        updatePhaseDisplay();
        updateProgressBar();
      initGame();
      });
      
      // Feedback functionality
      feedbackButton.addEventListener('click', () => {
        feedbackModal.style.display = feedbackModal.style.display === 'none' ? 'block' : 'none';
      });

      feedbackForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const feedback = feedbackForm.querySelector('textarea').value;
        const name = feedbackForm.querySelector('input[type="text"]').value;
        const email = feedbackForm.querySelector('input[type="email"]').value;
        
        try {
          if (!feedback.trim()) {
            throw new Error('Please enter some feedback before submitting');
          }

          // First save to local server
          const response = await fetch('/submit-feedback', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              feedback,
              name,
              email
            })
          });

          const data = await response.json();
          
          if (response.ok) {
            alert('Thank you for your feedback!');
            feedbackForm.querySelector('textarea').value = '';
            feedbackForm.querySelector('input[type="text"]').value = '';
            feedbackForm.querySelector('input[type="email"]').value = '';
            feedbackModal.style.display = 'none';
          } else {
            throw new Error(data.error || 'Failed to submit feedback');
          }
        } catch (error) {
          console.error('Detailed error:', error);
          
          // Create a more user-friendly error message
          let userMessage = 'Sorry, there was an error submitting your feedback: ';
          
          if (error.message.includes('Failed to fetch')) {
            userMessage += 'Network error - please check your internet connection.';
          } else if (error.message.includes('API Error')) {
            userMessage += error.message;
          } else {
            userMessage += error.message;
          }
          
          alert(userMessage);
        }
      });

      // Close modal when clicking outside
      document.addEventListener('click', (e) => {
        if (!feedbackModal.contains(e.target) && e.target !== feedbackButton) {
          feedbackModal.style.display = 'none';
        }
      });

      // Initialize variables for tracking word count
      totalWordsInFile = 0;
      
      // Initialize the game
      async function startGame() {
        try {
          // Load words once and store them globally
          const allWords = await loadWords();
          currentFileWords = allWords;
          totalWordsInFile = allWords.length;
          console.log(`Total words in file: ${totalWordsInFile}`);
          
          // Then initialize the game using saved words and state
          currentPhase = parseInt(localStorage.getItem('spellGamePhase')) || 1;
          currentFileIndex = parseInt(localStorage.getItem('spellGameFileIndex')) || 0;
          challengeMode = localStorage.getItem('spellGameChallengeMode') === 'true';
          updatePhaseDisplay();
          updateProgressBar();
          await initGame();
        } catch (error) {
          console.error("Error starting game:", error);
          currentWordElement.textContent = `Error loading game: ${error.message}`;
        }
      }
      
      // Start the game
      startGame();

      // Modify the handleKeyboardInput function:
      const handleKeyboardInput = (e) => {
        // Handle Escape key - reset all letters
        if (e.key === 'Escape') {
          const slots = sequenceContainer.querySelectorAll('.sequence-slot');
          slots.forEach(slot => {
            if (slot.firstChild) {
              draggablesContainer.appendChild(slot.firstChild);
            }
          });
          return;
        }

        // Handle Backspace key - remove rightmost letter
        if (e.key === 'Backspace') {
          const slots = Array.from(sequenceContainer.querySelectorAll('.sequence-slot'));
          // Find the rightmost filled slot
          for (let i = slots.length - 1; i >= 0; i--) {
            if (slots[i].firstChild) {
              draggablesContainer.appendChild(slots[i].firstChild);
              break;
            }
          }
          return;
        }

        // Existing letter key handling
        if (!/^[a-zA-Z]$/.test(e.key)) return;
        
        const letter = e.key.toLowerCase();
        const slots = sequenceContainer.querySelectorAll('.sequence-slot');
        const draggables = draggablesContainer.querySelectorAll('.draggable');
        
        // Find the first empty slot
        const emptySlot = Array.from(slots).find(slot => !slot.firstChild);
        if (!emptySlot) return; // No empty slots
        
        // Find matching draggable letter
        const matchingDraggable = Array.from(draggables).find(drag => 
          drag.textContent.toLowerCase() === letter && 
          !drag.parentElement.classList.contains('sequence-slot')
        );
        
        if (matchingDraggable) {
          // Move the letter to the empty slot
          emptySlot.appendChild(matchingDraggable);
          // Check if word is complete
          checkWord();
        }

        // Add to your handleKeyboardInput function
        if (e.ctrlKey) {
          switch(e.key) {
            case 'n': // Next word
              e.preventDefault();
              initGame();
              break;
            case 'p': // Next phase
              e.preventDefault();
              jumpToPhase(currentPhase + 1);
              break;
            case 'c': // Auto complete
              e.preventDefault();
              autoComplete();
              break;
            case 't': // Test file loading
              e.preventDefault();
              testFileLoad();
              break;
          }
        }
      };

      // In the DOMContentLoaded event listener, after other initialization code:
      document.addEventListener('keydown', handleKeyboardInput);

      // Add visual feedback for available keyboard letters
      const updateDraggableStyles = () => {
        const draggables = draggablesContainer.querySelectorAll('.draggable');
        draggables.forEach(draggable => {
          // Add keyboard hint to draggable letters
          const keyHint = document.createElement('span');
          keyHint.classList.add('key-hint');
          keyHint.textContent = draggable.textContent;
          draggable.setAttribute('title', `Press '${draggable.textContent}' key`);
        });
      };

      // Add debug controls
      if (DEBUG) {
        const debugControls = document.createElement('div');
        debugControls.style.position = 'fixed';
        debugControls.style.top = '10px';
        debugControls.style.left = '10px';
        debugControls.style.zIndex = '9999';
        debugControls.innerHTML = `
          <div style="background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; color: white;">
            <div style="margin-bottom: 8px;">
              <strong style="color: #3498db;">Core Phases:</strong><br>
              <button onclick="jumpToPhase(1)">Phase 1</button>
              <button onclick="jumpToPhase(2)">Phase 2</button>
              <button onclick="jumpToPhase(3)">Phase 3</button>
              <button onclick="jumpToPhase(4)">Phase 4</button>
              <button onclick="jumpToPhase(5)">Phase 5</button>
            </div>
            <div style="margin-bottom: 8px;">
              <strong style="color: #e74c3c;">Advanced Modules:</strong><br>
              <button onclick="jumpToPhase(6)">Module 1</button>
              <button onclick="jumpToPhase(7)">Module 2</button>
              <button onclick="jumpToPhase(8)">Module 3</button>
            </div>
            <div>
              <strong style="color: #2ecc71;">Debug Tools:</strong><br>
              <button onclick="autoComplete()">Auto Complete Word</button>
              <button onclick="skipToNextWord()">Skip Word</button>
              <button onclick="testFileLoad()">Test All Files</button>
            </div>
          </div>
        `;
        document.body.appendChild(debugControls);

        // Debug helper functions
        window.jumpToPhase = (phase) => {
          currentPhase = phase;
          currentFileIndex = 0;
          gameProgress = 0;
          localStorage.setItem('spellGamePhase', phase);
          localStorage.setItem('spellGameFileIndex', 0);
          localStorage.setItem('spellGameProgress', 0);
          startGame();
        };

        window.autoComplete = () => {
          const slots = sequenceContainer.querySelectorAll('.sequence-slot');
          const word = currentWord.split('');
          slots.forEach((slot, i) => {
            if (!slot.firstChild) {
              const letter = word[i];
              const draggable = Array.from(draggablesContainer.querySelectorAll('.draggable'))
                .find(d => d.textContent.toLowerCase() === letter.toLowerCase());
              if (draggable) slot.appendChild(draggable);
            }
          });
          checkWord();
        };

        window.skipToNextWord = () => {
          initGame();
        };

        window.testFileLoad = async () => {
          const results = document.createElement('div');
          results.style.position = 'fixed';
          results.style.right = '10px';
          results.style.top = '10px';
          results.style.background = 'white';
          results.style.padding = '10px';
          results.style.maxHeight = '80vh';
          results.style.overflow = 'auto';
          results.innerHTML = '<h3>File Load Test Results:</h3>';
          
          for (let phase = 1; phase <= maxPhase; phase++) {
            for (let fileIndex = 0; fileIndex < phaseFiles[phase].length; fileIndex++) {
              const filePath = phaseFiles[phase][fileIndex];
              try {
                const response = await fetch(filePath);
                const text = await response.text();
                const wordCount = text.split('\n').filter(w => w.trim()).length;
                results.innerHTML += `<div style="color: green">✓ ${filePath}: ${wordCount} words</div>`;
              } catch (error) {
                results.innerHTML += `<div style="color: red">✗ ${filePath}: ${error.message}</div>`;
              }
            }
          }
          document.body.appendChild(results);
        };
      }

      // Add a debug logger
      const debugLog = (message, data = null) => {
        if (DEBUG) {
          console.log(`[DEBUG] ${message}`, data || '');
        }
      };

      // Use throughout your code
      debugLog('Word loaded', currentWord);
      debugLog('Progress updated', gameProgress);
      debugLog('Phase change', { phase: currentPhase, file: currentFileIndex });

      if (DEBUG) {
        // Add state inspector that updates in real-time
        const stateInspector = document.createElement('div');
        stateInspector.style.position = 'fixed';
        stateInspector.style.left = '10px';
        stateInspector.style.bottom = '10px';
        stateInspector.style.background = 'rgba(0,0,0,0.8)';
        stateInspector.style.color = 'white';
        stateInspector.style.padding = '10px';
        stateInspector.style.fontFamily = 'monospace';
        stateInspector.style.zIndex = '1000';
        stateInspector.style.borderRadius = '5px';
        
        const updateStateDisplay = () => {
          stateInspector.innerHTML = `
            Current Phase: ${currentPhase}
            File Index: ${currentFileIndex}
            Progress: ${gameProgress}%
            Challenge Mode: ${challengeMode}
            Current Word: ${currentWord}
            Words Remaining: ${currentFileWords.length}
          `.replace(/\n/g, '<br>');
        };

        // Call this whenever state changes
        setInterval(updateStateDisplay, 1000);
        document.body.appendChild(stateInspector);
      }
    });
  </script>
</body>
</html>